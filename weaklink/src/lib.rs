//! This crate documents the runtime API for weaklink stubs generated by `weaklink_build`.
//!
//! Access to the API is through static variables exposed in the generated stubs crate:
//! - A [`Library`] object, named according to the configuration in `weaklink_build::Config`.
//! - A [`Group`] object for each symbol group defined via `weaklink_build::Config::add_symbol_group()`.
//!
//! # Checked Mode
//! Checked mode is a debugging tool that helps identify code paths using optional API groups
//! without first verifying their successful resolution.
//!
//! When the stub crate is compiled with the `checked` feature enabled, the API stubs verify that at least one of
//! the groups they belong to has been asserted as resolved by the current thread. If this condition is not met,
//! the stub pointer reverts to null, causing a process abort if the stub is called during that time.
//!
//! See also:  [`Group::resolve()`]
//!
//! ## Example
//! ```rust,ignore
//! // build.rs
//! use weaklink_build::{Config, SymbolStub};
//! fn main() {
//!     let mut config = Config::new("stub");
//!     config.add_symbol_group("base", vec![SymbolStub::new("base_api")]).unwrap();
//!     config.add_symbol_group("optional", vec![SymbolStub::new("optional_api")]).unwrap();
//!     ...
//! }
//! ```
//! ```rust,ignore
//! // main.rs
//! extern "C" {
//!     fn base_api();
//!     fn optional_api();
//! }
//!
//! fn main() -> Result<(), Box<dyn std::error::Error>> {
//!     stub::library.load_from("path/to/the/dynamic/library")?;
//!
//!     // Base API must be always present, or we can't use the library at all.
//!     stub::base.resolve()?.mark_permanent();
//!     unsafe { base_api(); }
//!
//!     let token = stub::optional.resolve()?;
//!     unsafe { optional_api(); }
//!     drop(token);
//!
//!     // This call will crash in checked mode!
//!     unsafe { optional_api(); }
//!
//!     Ok(())
//! }
//! ```

mod group;
pub mod loading;

use std::{
    cell::UnsafeCell,
    ffi::{CStr, CString},
    mem,
    path::Path,
    sync::atomic::{AtomicUsize, Ordering},
};

pub use group::{Group, GroupResolved};
pub use loading::{Address, DylibHandle};

pub type Error = Box<dyn std::error::Error>;

#[cfg(feature = "checked")]
use std::sync::{Mutex, MutexGuard, OnceLock};

/// Represents a weakly linked dynamic library.
#[repr(C)]
pub struct Library {
    handle: AtomicUsize,
    dylib_names: &'static [&'static str],
    symbol_names: &'static [&'static CStr],
    symbol_table: &'static [Address],

    // Must initialize this stuff lazily, so we can have a const constructor.
    #[cfg(feature = "checked")]
    checked_state: OnceLock<Mutex<CheckedState>>,
}

#[cfg(feature = "checked")]
struct CheckedState {
    asserted: Box<[u32]>,
}

impl Library {
    #[doc(hidden)]
    pub const fn new(
        dylib_names: &'static [&'static str],
        symbol_names: &'static [&'static CStr],
        symbol_table: &'static [Address],
    ) -> Library {
        Library {
            handle: AtomicUsize::new(0),
            dylib_names,
            symbol_names,
            symbol_table,
            #[cfg(feature = "checked")]
            checked_state: OnceLock::new(),
        }
    }

    /// Load library with default name (configured at build time).
    pub fn load(&self) -> Result<DylibHandle, Error> {
        let raw_handle = self.handle.load(Ordering::Acquire);
        if raw_handle != 0 {
            return Err("Already loaded.".into());
        } else {
            for name in self.dylib_names {
                let cpath = CString::new(*name).unwrap();
                if let Ok(handle) = loading::load_library(&cpath) {
                    self.handle.store(handle.0, Ordering::Release);
                    return Ok(handle);
                }
            }
        }
        Err("Library not found.".into())
    }

    /// Load library from the specified path.
    pub fn load_from(&self, path: &Path) -> Result<DylibHandle, Error> {
        let raw_handle = self.handle.load(Ordering::Acquire);
        if raw_handle != 0 {
            Err("Already loaded.".into())
        } else {
            let cpath = CString::new(path.as_os_str().to_str().unwrap().as_bytes()).unwrap();
            match loading::load_library(&cpath) {
                Ok(handle) => {
                    self.handle.store(handle.0, Ordering::Release);
                    Ok(handle)
                }
                Err(err) => Err(err),
            }
        }
    }

    /// Sets the library handle directly.
    ///
    /// The handle may be obtained via [`loading::load_library`] or from platform-specific APIs.
    pub fn set_handle(&self, handle: DylibHandle) {
        self.handle.store(handle.0, Ordering::Release);
    }

    /// Returns the library handle if it is loaded, or previously set via `set_handle`.
    pub fn handle(&self) -> Option<DylibHandle> {
        let raw_handle = self.handle.load(Ordering::Acquire);
        if raw_handle != 0 {
            Some(DylibHandle(raw_handle))
        } else {
            None
        }
    }

    // Make sure the library is loaded, or panic.
    fn ensure_loaded(&self) -> DylibHandle {
        match self.handle() {
            Some(handle) => handle,
            None => match self.load() {
                Ok(handle) => handle,
                Err(err) => panic!("{}", err),
            },
        }
    }

    // Resolve symbol address and update its entry in the symbol table.
    fn resolve_symbol(&self, sym_index: u32) -> Result<Address, Error> {
        unsafe {
            let entry = self.symbol_table_entry(sym_index);
            let handle = self.ensure_loaded();
            let sym_name = self.symbol_names[sym_index as usize];
            let address = loading::find_symbol(handle, sym_name)?;
            entry.write(address);
            Ok(address)
        }
    }

    // Get a reference to the symbol pointer at the specified index.
    unsafe fn symbol_table_entry(&self, sym_index: u32) -> *mut Address {
        let ptr: &UnsafeCell<Address> = mem::transmute(&self.symbol_table[0]);
        ptr.get().offset(sym_index as isize) as *mut Address
    }
}

#[cfg(not(feature = "checked"))]
impl Library {
    fn assert_resolved(&self, _sym_indices: &[u32]) {}

    fn deassert_resolved(&self, _sym_indices: &[u32]) {}
}

#[cfg(feature = "checked")]
impl Library {
    fn get_checked_state(&self) -> MutexGuard<CheckedState> {
        let mutex = self.checked_state.get_or_init(|| {
            Mutex::new(CheckedState {
                asserted: Self::boxed_slice(self.symbol_table.len()),
            })
        });
        mutex.lock().unwrap()
    }

    fn assert_resolved(&self, sym_indices: &[u32]) {
        let mut checked_state = self.get_checked_state();
        for sym_index in sym_indices {
            checked_state.asserted[*sym_index as usize] += 1;
        }
    }

    fn deassert_resolved(&self, sym_indices: &[u32]) {
        let mut checked_state = self.get_checked_state();
        for sym_index in sym_indices {
            checked_state.asserted[*sym_index as usize] -= 1;
            if checked_state.asserted[*sym_index as usize] == 0 {
                // All threads have de-asserted, so noone should be using this entry.
                unsafe {
                    self.symbol_table_entry(*sym_index).write(0);
                }
            }
        }
    }

    fn boxed_slice<T: Copy + Default>(size: usize) -> Box<[T]> {
        let mut v = Vec::<T>::with_capacity(size);
        v.resize(size, Default::default());
        v.into_boxed_slice()
    }
}
